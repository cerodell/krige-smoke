{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "c2f8f71e",
   "metadata": {},
   "source": [
    "# Universal Kriging (UK)\n",
    "Universal Kriging (UK) is a variant of the Ordinary Kriging under non-stationary condition where mean differ in a deterministic way in different locations (local trend or drift), while only the variance is constant. This second-order stationarity (“weak stationarity”) is often a pertinent assumption with environmental exposures. In UK, usually first trend is calculated as a function of the coordinates and then the variation in what is left over (the residuals) as a random field is added to trend for making final prediction.\n",
    "\n",
    "$$\n",
    "\\begin{aligned} Z\\left(s_{i}\\right) &=m\\left(s_{i}\\right)+e\\left(s_{i}\\right) \\\\ Z(\\vec{x}) &=\\sum_{k=0}^{K} \\beta_{k} f_{k}(\\vec{x})+\\varepsilon(\\vec{x}) \\end{aligned}\n",
    "$$\n",
    "\n",
    "\n",
    "- Where the $f_{k}$ are some global functions of position  $\\vec{x}$  and the  $\\beta_{k}$ are the coefficients.   \n",
    "\n",
    "- The $f$ are called base functions. The  $\\varepsilon(\\vec{x})$  is the spatially-correlated error, which is modelled as before, with a variogram, but now only considering the residuals, after the global trend is removed."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4a58df3e",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "Load python modules"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "26f89f24",
   "metadata": {},
   "outputs": [],
   "source": [
    "import context\n",
    "import salem\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import xarray as xr\n",
    "import geopandas as gpd\n",
    "import cartopy.crs as ccrs\n",
    "import matplotlib.pyplot as plt\n",
    "from pykrige.uk import UniversalKriging\n",
    "\n",
    "import plotly.express as px\n",
    "from datetime import datetime\n",
    "\n",
    "from utils.utils import pixel2poly, plotvariogram\n",
    "from context import data_dir"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6344639a",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "## Load Data\n",
    "Open the reformated data with the linear, meter-based Lambert projection (EPSG:3347). \n",
    "- Again this is helpful as lat/lon coordinates are less suitable for measuring distances which is important for spatial interpolation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9d41ad33",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "df = pd.read_csv(str(data_dir) + \"/obs/gpm25.csv\")\n",
    "gpm25 = gpd.GeoDataFrame(\n",
    "    df,\n",
    "    crs=\"EPSG:4326\",\n",
    "    geometry=gpd.points_from_xy(df[\"lon\"], df[\"lat\"]),\n",
    ").to_crs(\"EPSG:3347\")\n",
    "gpm25[\"Easting\"], gpm25[\"Northing\"] = gpm25.geometry.x, gpm25.geometry.y\n",
    "gpm25.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3d8b5efa",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "### Create Grid\n",
    "Again we will create a grid that we want to use for the interpolation.\n",
    "\n",
    "- The grid in the fromate of a dataset is helpful for reprojecting our covariates to match the interpolated grid."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fe4152d5",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "## define the desired  grid resolution in meters\n",
    "resolution = 20_000  # grid cell size in meters\n",
    "\n",
    "## make grid based on dataset bounds and resolution\n",
    "gridx = np.arange(\n",
    "    gpm25.bounds.minx.min() - resolution,\n",
    "    gpm25.bounds.maxx.max() + resolution,\n",
    "    resolution,\n",
    ")\n",
    "gridy = np.arange(\n",
    "    gpm25.bounds.miny.min() - resolution,\n",
    "    gpm25.bounds.maxy.max() + resolution,\n",
    "    resolution,\n",
    ")\n",
    "\n",
    "## use salem to create a dataset with the grid.\n",
    "krig_ds = salem.Grid(\n",
    "    nxny=(len(gridx), len(gridy)),\n",
    "    dxdy=(resolution, resolution),\n",
    "    x0y0=(gpm25.bounds.minx.min(), gpm25.bounds.miny.min()),\n",
    "    proj=\"epsg:3347\",\n",
    "    pixel_ref=\"corner\",\n",
    ").to_dataset()\n",
    "## print dataset\n",
    "krig_ds"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0096c768",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "### Covariate \n",
    "We will use aersoal optical depth (AOD) as a covariate for universal kriging with specified drift. The data is from the [modis aqua](https://www.nsstc.uah.edu/data/sundar/MODIS_AOD_L3_HRG/) satellite during the datetime of interest\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f1ea0208",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "aod_aqua_ds = salem.open_xr_dataset(str(data_dir) + f\"/MYD04.2021197.G10.nc\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f849cf1d",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "## Set up specified drift\n",
    "For specified we need satellite derived aod at every aq monitor location and AOD on the same grid we are interpolating."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ac0bcedb",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "### AOD at AQs location"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7719b4ef",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "\n",
    "y = xr.DataArray(\n",
    "    np.array(df[\"lat\"]),\n",
    "    dims=\"ids\",\n",
    "    coords=dict(ids=df.id.values),\n",
    ")\n",
    "x = xr.DataArray(\n",
    "    np.array(df[\"lon\"]),\n",
    "    dims=\"ids\",\n",
    "    coords=dict(ids=df.id.values),\n",
    ")\n",
    "var_points = aod_aqua_ds[\"AOD_550_GF_SM\"].interp(\n",
    "    Longitude=x, Latitude=y, method=\"linear\"\n",
    ")\n",
    "# print(var_points)\n",
    "if len(df.index) == len(var_points.values):\n",
    "    var_points = var_points.values\n",
    "else:\n",
    "    raise ValueError(\"Lenghts dont match\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "30728200",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "### AOD Data on grid\n",
    "Now we will transform the aod data to be on the grid we are interpolating too. This is feed in as a specified drift array when executing the interpolation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6356b67f",
   "metadata": {},
   "outputs": [],
   "source": [
    "aod_aqua_ds_T = krig_ds.salem.transform(aod_aqua_ds)\n",
    "var_array = aod_aqua_ds_T[\"AOD_550_GF_SM\"].values"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "267f6f9a",
   "metadata": {},
   "source": [
    "#### Plot AOD"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d18f16ea",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "ax = plt.axes(projection=ccrs.Orthographic(-80, 35))\n",
    "ax.set_global()\n",
    "aod_aqua_ds[\"AOD_550_GF_SM\"].plot(ax=ax, transform=ccrs.PlateCarree())\n",
    "ax.coastlines()\n",
    "ax.set_extent([-132, -85, 35, 65], crs=ccrs.PlateCarree())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "167ab04b",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "##  Setup UK"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "423073f5",
   "metadata": {},
   "outputs": [],
   "source": [
    "nlags = 15\n",
    "variogram_model = \"spherical\"\n",
    "\n",
    "\n",
    "startTime = datetime.now()\n",
    "krig = UniversalKriging(\n",
    "    x=gpm25[\"Easting\"],  ## x location of aq monitors in lambert conformal\n",
    "    y=gpm25[\"Northing\"],  ## y location of aq monitors in lambert conformal\n",
    "    z=gpm25[\"PM2.5\"],  ## measured PM 2.5 concentrations at locations\n",
    "    drift_terms=[\"specified\"],\n",
    "    variogram_model=variogram_model,\n",
    "    nlags=nlags,\n",
    "    specified_drift=[var_points],  ## aod at aq monitors\n",
    ")\n",
    "print(f\"UK build time {datetime.now() - startTime}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bacd62bb",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "#### Our variogram parameters\n",
    "PyKrige will optimize most parameters based on user defined empirical model and the number of bins.\n",
    "\n",
    "- I tested several empirical models and bin sizes and found (for this case study) that a spherical model with 15 bins was optimal based on the output statics.\n",
    "\n",
    " - The literature supports spherical for geospatial interpolation applications over other methods."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "727c3dcf",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "plotvariogram(krig)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "665ff471",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "### Execute UK\n",
    "Interpolate data to our grid using UK with specified drift. Where the specified drift is the linear correlation of AOD to PM2.5 at all locations and on the interploated grid for kriging."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "167f40d2",
   "metadata": {},
   "outputs": [],
   "source": [
    "startTime = datetime.now()\n",
    "z, ss = krig.execute(\"grid\", gridx, gridy, specified_drift_arrays=[var_array])\n",
    "print(f\"UK execution time {datetime.now() - startTime}\")\n",
    "UK_pm25 = np.where(z < 0, 0, z)\n",
    "\n",
    "krig_ds[\"UK_pm25\"] = ((\"y\", \"x\"), UK_pm25)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d3d77405",
   "metadata": {},
   "source": [
    "### Plot UK\n",
    "Convert data to polygons to be plot-able on a slippy mapbox. This is not necessary but but :)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21c99695",
   "metadata": {},
   "outputs": [],
   "source": [
    "polygons, values = pixel2poly(gridx, gridy, UK_pm25, resolution)\n",
    "pm25_model = gpd.GeoDataFrame(\n",
    "    {\"Modelled PM2.5\": values}, geometry=polygons, crs=\"EPSG:3347\"\n",
    ").to_crs(\"EPSG:4326\")\n",
    "\n",
    "fig = px.choropleth_mapbox(\n",
    "    pm25_model,\n",
    "    geojson=pm25_model.geometry,\n",
    "    locations=pm25_model.index,\n",
    "    color=\"Modelled PM2.5\",\n",
    "    color_continuous_scale=\"jet\",\n",
    "    center={\"lat\": 50.0, \"lon\": -110.0},\n",
    "    zoom=2.5,\n",
    "    mapbox_style=\"carto-positron\",\n",
    "    opacity=0.6,\n",
    ")\n",
    "fig.update_layout(margin=dict(l=0, r=0, t=30, b=10))\n",
    "fig.update_traces(marker_line_width=0)"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all",
   "main_language": "python",
   "notebook_metadata_filter": "-all"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
